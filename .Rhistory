shiny::runApp('Devel/R/AppShiny')
install.packages("cartography")
library(sf)
library(cartography)
# path to the geopackage file embedded in cartography
path_to_gpkg <- system.file("gpkg/mtq.gpkg", package="cartography")
# import to an sf object
mtq <- st_read(dsn = path_to_gpkg, quiet = TRUE)
# Create a grid layer
mygrid <- getGridLayer(
x = mtq,
cellsize = (median(st_area(mtq))),
var = c("POP"),
type = "regular"
)
# Compute population density in people per km2
mygrid$POPDENS <- 1e6 * mygrid$POP / mygrid$gridarea
# plot municipalities (only the backgroung color is plotted)
plot(st_geometry(mtq), col = NA, border = NA, bg = "#deffff")
# Plot the population density
choroLayer(x = mygrid, var = "POPDENS", method = "geom", nclass=5,
col = carto.pal(pal1 = "turquoise.pal", n1 = 5), border = "grey80",
lwd = 0.5, legend.pos = "topright", add = TRUE,
legend.title.txt = "Population Density\n(people per km2)")
# Título
# layoutLayer(title = "Population Distribution in Martinique",
#             sources = "Sources: Insee and IGN, 2018",
#             author = paste0("cartography ", packageVersion("cartography")),
#             frame = FALSE, north = FALSE, tabtitle = TRUE,
#             theme = "turquoise.pal")
# north arrow
# north(pos = "topleft")
# ARG_adm1.shp tiene las formas de las provincias.
argentina <- readOGR(dsn="./ARG_adm/ARG_adm1.shp")
# ARG_adm1.csv tiene los nombres de las provincias para la detección.
bsas <- subset(argentina, str_detect(NAME_1, "Buenos Aires"))
# Determinar el límite rectangular de la provincia
#         min       max
# x -63.39386 -56.66736
# y -41.03542 -33.26014
bbox(bsas)
e <- extent(bbox(bsas))
# Convertir a objeto raster
r <- raster(e)
# Dividir en grilla de 25 x 25
dim(r) <- c(25, 25)
projection(r) <- crs(proj4string(bsas))
# Agregar ID de etiqueta a las celdas
r <- setValues(r, 1:ncell(r))
# Reconvertir en un archivo de forma para crear un popup del ID de celda para cada polígono
shape <- rasterToPolygons(r, dissolve = TRUE)
# Recortar las celdas de la grilla que contengan el polígono de la provincia
p <- shape[bsas, ]
# Recortar el perímetro de la grilla para coincidir con el polígono de la provincia
cat("map <- gIntersection\n")
map <- gIntersection(p, bsas, byid = TRUE, drop_lower_td = TRUE)
cat("terminado...\n")
# Crear un popup usando la capa de etiquetas de las celdas de la grilla
pop <- p@data$layer
# Crear el mapa
leaflet(map) %>%
addTiles %>%
addPolygons(stroke = TRUE, opacity = 1, fillOpacity = 0.05, popup = pop,
smoothFactor = 0.5, color="black", fillColor = NULL, weight = 0.5)
library(dplyr)
library(rgeos)
library(rgdal)
library(sp)
library(leaflet)
library(raster)
library(stringr)
# ARG_adm1.shp tiene las formas de las provincias.
argentina <- readOGR(dsn="./ARG_adm/ARG_adm1.shp")
# ARG_adm1.csv tiene los nombres de las provincias para la detección.
bsas <- subset(argentina, str_detect(NAME_1, "Buenos Aires"))
# Determinar el límite rectangular de la provincia
#         min       max
# x -63.39386 -56.66736
# y -41.03542 -33.26014
bbox(bsas)
e <- extent(bbox(bsas))
# Convertir a objeto raster
r <- raster(e)
# Dividir en grilla de 25 x 25
dim(r) <- c(25, 25)
projection(r) <- crs(proj4string(bsas))
# Agregar ID de etiqueta a las celdas
r <- setValues(r, 1:ncell(r))
# Reconvertir en un archivo de forma para crear un popup del ID de celda para cada polígono
shape <- rasterToPolygons(r, dissolve = TRUE)
# Recortar las celdas de la grilla que contengan el polígono de la provincia
p <- shape[bsas, ]
# Recortar el perímetro de la grilla para coincidir con el polígono de la provincia
cat("map <- gIntersection\n")
map <- gIntersection(p, bsas, byid = TRUE, drop_lower_td = TRUE)
cat("terminado...\n")
# Crear un popup usando la capa de etiquetas de las celdas de la grilla
pop <- p@data$layer
# Crear el mapa
leaflet(map) %>%
addTiles %>%
addPolygons(stroke = TRUE, opacity = 1, fillOpacity = 0.05, popup = pop,
smoothFactor = 0.5, color="black", fillColor = NULL, weight = 0.5)
setwd("Devel/R/AppLeafletBsAs/")
library(dplyr)
library(rgeos)
library(rgdal)
library(sp)
library(leaflet)
library(raster)
library(stringr)
# ARG_adm1.shp tiene las formas de las provincias.
argentina <- readOGR(dsn="./ARG_adm/ARG_adm1.shp")
# ARG_adm1.csv tiene los nombres de las provincias para la detección.
bsas <- subset(argentina, str_detect(NAME_1, "Buenos Aires"))
# Determinar el límite rectangular de la provincia
#         min       max
# x -63.39386 -56.66736
# y -41.03542 -33.26014
bbox(bsas)
e <- extent(bbox(bsas))
# Convertir a objeto raster
r <- raster(e)
# Dividir en grilla de 25 x 25
dim(r) <- c(25, 25)
projection(r) <- crs(proj4string(bsas))
# Agregar ID de etiqueta a las celdas
r <- setValues(r, 1:ncell(r))
# Reconvertir en un archivo de forma para crear un popup del ID de celda para cada polígono
shape <- rasterToPolygons(r, dissolve = TRUE)
# Recortar las celdas de la grilla que contengan el polígono de la provincia
p <- shape[bsas, ]
# Recortar el perímetro de la grilla para coincidir con el polígono de la provincia
cat("map <- gIntersection\n")
map <- gIntersection(p, bsas, byid = TRUE, drop_lower_td = TRUE)
cat("terminado...\n")
# Crear un popup usando la capa de etiquetas de las celdas de la grilla
pop <- p@data$layer
# Crear el mapa
leaflet(map) %>%
addTiles %>%
addPolygons(stroke = TRUE, opacity = 1, fillOpacity = 0.05, popup = pop,
smoothFactor = 0.5, color="black", fillColor = NULL, weight = 0.5)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
